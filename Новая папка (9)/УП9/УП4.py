def sort_like_nums(nums):
    n = len(nums)

    # Внешний цикл: проходим по каждому элементу, чтобы поставить его на правильное место
    for i in range(n - 1):
        # Изначально считаем, что текущий элемент (nums[i]) - это минимальный
        index_min = i

        # Внутренний цикл: ищем настоящий минимальный элемент в оставшейся несортированной части
        for j in range(i + 1, n):
            # Получаем текущий элемент (k) и предполагаемый минимальный (kl)
            k = nums[j]
            kl = nums[index_min]

            # Извлекаем фактическое числовое значение для сравнения:
            # если элемент - int, используем его напрямую; если list, берем первый элемент.
            ok = k if isinstance(k, int) else k[0]
            okl = kl if isinstance(kl, int) else kl[0]

            # Сравниваем числовые значения: если текущее меньше, обновляем index_min
            if ok < okl:
                index_min = j
            # Если значения равны, также обновляем index_min.
            # Эта часть 'elif ok == okl' делает сортировку НЕСТАБИЛЬНОЙ для равных элементов,
            # так как она всегда будет выбирать элемент с большим индексом 'j'
            # (то есть, тот, что встретился позже), если их значения 'ok' и 'okl' одинаковы.
            # Для стабильной сортировки этот 'elif' блок нужно удалить.
            elif ok == okl:
                index_min = j

        # Меняем местами текущий элемент с найденным минимальным
        nums[i], nums[index_min] = nums[index_min], nums[i]


# Тестовые примеры:
nums = [[4], 3, 2, [5], [1]]
sort_like_nums(nums)
print(nums) # Ожидается: [[1], 2, 3, [4], [5]]

nums = [2, 1, [2], 3, [3]]
sort_like_nums(nums)
print(nums) # Ожидается: [1, 2, [2], 3, [3]] (или [1, [2], 2, 3, [3]] из-за нестабильности)

nums = [[1]]
sort_like_nums(nums)
print(nums) # Ожидается: [[1]]

nums = [[1], 1]
sort_like_nums(nums)
print(nums) # Ожидается: [[1], 1] или [1, [1]] (из-за нестабильности)

nums = [[4], [3], [2], [5], [1]]
sort_like_nums(nums)
print(nums) # Ожидается: [[1], [2], [3], [4], [5]]

nums = [-1, [-1], [-2], -2, [-1]]
sort_like_nums(nums)
print(nums) # Ожидается: [-2, [-2], -1, [-1], [-1]] (или другой порядок для равных -1)