def number_of_swaps(nums):
    n = len(nums)
    counter = 0  # Инициализируем счетчик обменов

    # Внешний цикл для проходов по массиву (n-1 проход максимум)
    for i in range(n - 1):
        swapped = False  # Флаг для отслеживания, были ли обмены в текущем проходе

        # Внутренний цикл для "всплывания" наибольшего несгруппированного элемента
        # на его правильное место в конце массива
        for j in range(n - i - 1):
            # Если текущий элемент больше следующего, меняем их местами
            if nums[j] > nums[j + 1]:
                counter += 1  # Увеличиваем счетчик обменов
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
                swapped = True  # Устанавливаем флаг, что обмен произошел

        # Если в текущем проходе не было обменов, значит, массив уже отсортирован
        # и дальнейшие проходы не нужны. Оптимизация!
        if not swapped:
            break
            
    return counter  # Возвращаем общее количество обменов


# Тестовые примеры:
print(number_of_swaps([1, 2, 4, 3, 5]))  # Ожидается: 1 (4 и 3 поменяются местами)
print(number_of_swaps([2, 1, 4, 3, 5]))  # Ожидается: 2 (2 и 1; 4 и 3)
print(number_of_swaps([1, 2, 3, 4, 5]))  # Ожидается: 0 (уже отсортирован)
print(number_of_swaps([5, 4, 3, 2, 1]))  # Ожидается: 10 (худший случай для пузырьковой сортировки)
print(number_of_swaps([1]))              # Ожидается: 0
print(number_of_swaps([2, 1]))           # Ожидается: 1