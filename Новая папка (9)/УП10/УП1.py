ddef insertion_sort(nums):
    n = len(nums)  # определяем длину списка

    # начинаем с первого элемента (индекс 1), так как элемент с индексом 0 считается отсортированным
    for i in range(1, n):
        item = nums[i]  # сохраняем текущий элемент, который будем вставлять в отсортированную часть
        j = i - 1  # индекс последнего элемента в отсортированной части

        # перемещаем элементы отсортированной части, которые больше текущего элемента, вправо
        while j >= 0 and item > nums[j]:  # условие item > nums[j] для сортировки по убыванию
            nums[j + 1] = nums[j]  # сдвигаем элемент вправо
            j -= 1  # переходим к предыдущему элементу в отсортированной части

        # вставляем текущий элемент на найденную позицию в отсортированной части
        nums[j + 1] = item


# тестовые случаи
nums = [3, 4, 1, 2, 5]
insertion_sort(nums)
print(nums)  # вывод: [5, 4, 3, 2, 1] (отсортировано по убыванию)

nums = [3, 2, 2, 1, 3, 3]
insertion_sort(nums)
print(nums)  # вывод: [3, 3, 3, 2, 2, 1]

nums = [1]
insertion_sort(nums)
print(nums)  # вывод: [1] (массив из одного элемента уже отсортирован)

nums = [5, 4, 3, 2, 1]
insertion_sort(nums)
print(nums)  # вывод: [5, 4, 3, 2, 1] (массив уже отсортирован по убыванию)

nums = [-2, -10, -7, -6]
insertion_sort(nums)
print(nums)  # вывод: [-2, -6, -7, -10] (отсортировано по убыванию)

nums = [-3, -3, -3, -3]
insertion_sort(nums)
print(nums)  # вывод: [-3, -3, -3, -3] (все элементы одинаковы)